# 使用说明
  在目录下使用`mvn package`即可在target目录下生成可执行文件，双击或者使用`java -tar`命令即可运行。
  
  采用鼠标和键盘的方式进行交互，可以响应的按键有重新开始（R）、继续\暂停（Space）、读取录像（L）。
  
  战斗记录会在战斗结束后自动保存，以当前“年-月-日-时-分-秒.replay”命名。
  
  同源代码一并上传了一份战斗记录，命名为“sample.replay”

# 代码结构说明
  这个工程文件主要由GUIWindow、Creature和Battlefield三个主要类和一些其他的辅助类构成，接下来对这三个主要类进行介绍
  ## GUIWindow
    GUIWindow主要负责动画展示和与用户的交互，同时负责计时和状态控制。基于这一特点，GUIWindow被设计为单例。GUIWindow中有三个域用于记录当前的状态，分别为replayMode（是否在播放战斗录像）、running（是否正在运行）、completed（是否已经完成）。 GUIWindow继承了JFrame类，并加入了一些Jpanel组件，用于处理用户交互信息、响应计时器和展示动画。
    
  ## Battlefield
     Battlefield用于对战场进行管理，采用信号量的方式避免多个生物体的位置发生冲突。
     
  ## Creature
    顾名思义，这个负责实现每一个生物体的行动。每个生物体在战斗过程中遵照相同的行为方式：先检查是否有攻击范围内的敌人，若有则进行攻击，否则向敌人移动。
    
    自然，生物体之间存在差异，通过对Creature类的继承体现了这种差异。
    
    为了遵循作业要求实现多线程的同时又避免各战斗速度不受控制，勉为其难地在GUIWindow和Creature各加入了一个`int tick`域，GUIWindow中的tick和Swing.Timer触发的时间事件递增，Creature中的tick则在每次线程执行的情况下加一，同时保证不超过GUIWindow中的tick值。这种方式相比于由Swing.Timer触发每个对象随机排序后轮流执行相比没有任何好处。
    
    每个生物体的位置由row、column、x、y四个int域记录。
    
    x,y属性记录单位在屏幕中的位置，而row，column记录32*20的格子化的战场中的位置。
    
    不将这二者统一起来的原因在于：
        一、如果将每一帧中各单位的位置格子化，那么战斗动画的连续性会很
        二、如果放弃格子化，那么
            1、将与项目要求不符（所以这不是我的锅）
            2、每个单位将占据成百上千个像素点，为所有像素点都设计一个信号量加锁来实现避免碰撞是不现实的，因为
                1）时间开销很大
                2）极有可能造成死锁      
               （这种情况各单位轮流执行比多线程靠谱得多，然而项目要求告诉我不能这么做，所以这也不是我的锅）
      因此采用这样一种设计，每个生物在移动阶段必须由一个格子移动向另一个格子(且在移动过程之中不得攻击)，从而每个单位最多同时持有两个信号量
     

     
# 不足之处
    在写代码框架的时候将每一个葫芦娃设计成为一个独立的类，其原计划是想为每一个葫芦娃设计独立的攻击方式或技能，然而由于在deadline前实现某必要功能时出现了一点意想不到的错误，这锦上添花的部分就没有机会实现了。
    
    restart操作在一些情况下会出现错误，原因在于原有的线程可能没有在第一时间终止。正常退出的方式不能保证第一时间退出，而stop()方法因为过于粗暴被编译器警告。然而，重新开始并不是作业要求，（所以不用就好）。
    
